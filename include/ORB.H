/* Copyright 2000-2018 Matt Flax <flatmax@flatmax.org>
   This file is part of GTK+ IOStream class set

   GTK+ IOStream is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   GTK+ IOStream is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You have received a copy of the GNU General Public License
   along with GTK+ IOStream
 */
#ifndef ORB_H_
#define ORB_H_

#ifndef _MSC_VER
#include "config.h" // generated as part of autotools
#endif

#ifndef ZEROC_ICE_EMBEDDED
#include <Ice/Ice.h>
#include <IceUtil/Mutex.h>
#else
#include <IceE/IceE.h>
#include <IceE/Mutex.h>
#endif

#include <list>
#include <iostream>
#include <sstream>
#include <vector>
using namespace std;

#include "ORBICE.H"

/*#ifdef _MSC_VER
#ifdef CREATING_DLL
#define SHARED __declspec( dllexport )
#else
#define SHARED __declspec( dllimport )
#endif
#else
#define SHARED
#endif
*/

namespace ORB {

#define ORB_DEFAULT_BASEPORT 10000 ///< The default base port for networking

/** Basic type to have remote procedure call And serialisation (Object request Broking) provided by ZeroC ICE (www.zeroc.com)

Here is an example of how to setup a class which interfaces a ORB network protocol (ORBTestICE.ice below) :
\code
class ORBTestClass : public ORBObject<ORBTEST::ORBTestICE> {
    //implement the virtual method which is in the ORBTestICE.ice protocol
    int method(int input, const Ice::Current& c){
        return input+1;
    }
};
template<> const string ORBTestClass::ORBObject<ORBTEST::ORBTestICE>::name("ORBTestClass"); // setup the type identity of the class
\endcode

Where the ORBTestICE.ice file looks like so :
\code
// Author Matt Flax <flatmax@>
// Date: 2013.05.02

#ifndef ORBTESTICE_ICE_
#define ORBTESTICE_ICE_

module ORBTEST {
    // a class with a simple method and variable
    class ORBTestICE {
        int method(int input);
        float variable;
    };
};
#endif // ORBTESTICE_ICE_
\endcode

\tparam ZEROCICETYPE The class generated by splice2cpp on your ice file
*/
template <class ZEROCICETYPE>
class ORBObject : public ZEROCICETYPE {
public:
    const static string name;///< The name of this class - once set, it can't be changed
};

/** Common class to maintain port offsets
The offsetList is a list of integers which represents available port offsets from a network basePort.
Each time ORBBase::getPortOffset() is called, the first available port offset is added to the list of used offsets (offsetList) and returned.
This class also provides methods for generating the actual TCP, UDP and SSL socket ports from the provided details and the class state.
This class also provides a method for generating sensible Zeroc ICE endpoint (and proxy) strings using the ORBBase::generateEndPoint method. The
ORBBase::generateEndPoint method is used for both the ORBOriginator and ORBReplicator sides of the network.
*/
class ORBBase {
    int basePort; ///< The starting network port
    IceUtil::Mutex countMutex; ///< Mutex semaphore to enable the manipulation of the offsetList
    list<int> offsetList; ///< The list of port offsets used
    /** initialise the class
    \param basePortDifferent the intended basePort value
    */
    void init(int basePortDifferent) {
        basePort=basePortDifferent;
    }
public:
    /// Constructor using ORB_DEFAULT_BASEPORT as the starting base network port
    ORBBase(void) {
        init(ORB_DEFAULT_BASEPORT);
    }
    ORBBase(int basePortDifferent) {
        init(basePortDifferent);
    }
    /** Get a new port offset to use
    \return an un-used port offset
    */
    int getPortOffset(void) {
        countMutex.lock();

        int i=-1;
        if (offsetList.size()>0) {
            // insert the first missing number
            offsetList.sort();
            std::list<int>::iterator offset=offsetList.begin();
            while (*(offset++)==++i) ; // find the first missing number
        } else // the list is empty
            i=0;
        offsetList.push_back(i); // add the missing number to the list

        countMutex.unlock();
        return i;
    }

    /** Remove a port offset from the offsetList, which will free it up for future use
    \param whichOffset is the port offset to remove from the list if present
    */
    void removePortOffset(int whichOffset) {
        countMutex.lock();
        offsetList.remove(whichOffset);
        countMutex.unlock();
    }

    /** Get the TCP and UDP ports for connection
    \param portOffset The portOffset to use
    \return The UDP and TCP port matching the supplied portOffset
    */
    int getTCPUDPPort(int portOffset) {
        return basePort+2*portOffset;
    }

    /** Get the SSL port for connection
    NOTE: currently SSL is not activated in generateEndPoint because it requires a valid cert.
    \param portOffset The portOffset to use
    \return The SSL port matching the supplied portOffset
    */
    int getSSLPort(int portOffset) {
        return getTCPUDPPort(portOffset)+1;
    }

    /** Get the base port.
    This base port is the port to connect to on the originator of the network layer
    \return basePort The base port of the system
    */
    int getBasePort(void) {
        return basePort;
    }

    /** Generates an endpoint string specifying where others will connect to OR what to connect to.
    \param transportName is the name of the application layer property which will provide ORB services
    \param ipAddress if not empty, then append the host's ip address (or hostname) to connect to, otherwise, if empty, generate the endpoint string to route to a machine on a network
    \param portOffset The offset from the basePort to use
    \return a suitable end point string
    */
    string generateEndPoint(const string& transportName, std::string& ipAddress, int& portOffset) {
        string tn=transportName, ia=ipAddress;
        int po=portOffset;
        return generateEndPoint(tn, ia, po);
    }

    /** generates an endpoint string specifying where others will connect to OR what to connect to.
    \param transportName is the name of the application layer property which will provide ORB services
    \param ipAddress if not empty, then append the host's ip address (or hostname) to connect to, otherwise, if empty, generate the endpoint string to route to a machine on a network
    \param portOffset The offset from the basePort to use
    \return a suitable end point string
    */
    string generateEndPoint(string &transportName, string ipAddress, int portOffset) {
        stringstream endPoint;
        if (ipAddress.size()>0) { // if we are setting up a proxy string
            ipAddress=string(" -h ")+ipAddress+' ';
            endPoint<<transportName<<":";
        }
        endPoint<<"tcp " <<ipAddress<< "-p "<<getTCPUDPPort(portOffset);
#ifndef ZEROC_ICE_EMBEDDED
        endPoint<<" : udp "<<ipAddress<<"-p "<<getTCPUDPPort(portOffset);
#endif
        cout<<"endpoint :"<<endl;
        cout<<endPoint.str()<<endl;
        // currently ssl is not activated ... this can be activated but would require certs
        //endPoint<<"tcp " <<ipAddress<< "-p "<<getTCPUDPPort(portOffset)<<":udp "<<ipAddress<<"-p "<<getTCPUDPPort(portOffset)<<":ssl "<<ipAddress<<"-p "<<getSSLPort(portOffset); // get the TCP, USP and SSL ports
        return endPoint.str();
    }
};

/** Sets up an originator which others can connect to as replicators.
The general idea is that any local classes can be added to the ORB network application layer using the ORBOriginator::addClass method.
Once these classes have been added to the ORB network, the ORBReplicator class can be used to access them on the other end of the network.
Maintains required resident classes (such as the communicator and adapter)

NOTE: Before using this class, you will require an install of the ZeroC ICE system (see http://www.zeroc.com/download.html for binary installers)
On Debian derived systems : sudo apt-get install zeroc-ice34 libzeroc-ice34-dev ice34-translators

NOTE: If your version of slice2cpp generates errors when executing slice2cpp on the ORBICE.ice file, then you will need to upgrade to version 3.5 of the Zeroc ICE software.

To use this class and the ice files, look at the Makefile for how to generate C++ code from the network protocol .ice files and then how to compile them.

*/
class ORBOriginator : public ORB::ORBICE, virtual public ORBBase {
protected:
    int portOffset; ///< The port offset of this application layer
    string hostAddress; ///< The hostname or IP address of the node to connect to, empty for the originator and set for the replicator

    string transportName; ///< Zeroc ICE application layer name
    Ice::CommunicatorPtr communicator; ///< Resident communicator
    Ice::ObjectAdapterPtr adapterPtr; ///< Resident adapter

    /** Generates a new ZeroC ICE application layer to connect to the originator (used by the ORBReplicator).
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting (used by ORBReplicator)
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, string ipAddress) {
        initialise(argc, argv, transportNameIn, ipAddress, vector<pair<string,string> >()); // initialise the communicator and adapter
    }

    /** Generates a new ZeroC ICE application layer to connect to the originator (used by the ORBReplicator).
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting (used by ORBReplicator)
    \param extraProperties Extra communicator properties to initialise the communicator with
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, string ipAddress, const vector<pair<string,string> > extraProperties) {
        initialise(argc, argv, transportNameIn, ipAddress, extraProperties); // initialise the communicator and adapter
    }

    /** Generates a new ZeroC ICE application layer to connect to the originator (used by the ORBReplicator).
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting (used by ORBReplicator)
    \param basePortDifferent Specify a different base port to the default normally used by ORBBase
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, string ipAddress, int basePortDifferent): ORBBase(basePortDifferent) {
        initialise(argc, argv, transportNameIn, ipAddress, vector<pair<string,string> >()); // initialise the communicator and adapter
    }

    /** Generates a new ZeroC ICE application layer to connect to the originator (used by the ORBReplicator).
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting (used by ORBReplicator)
    \param extraProperties Extra communicator properties to initialise the communicator with
    \param basePortDifferent Specify a different base port to the default normally used by ORBBase
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, string ipAddress, const vector<pair<string,string> > extraProperties, int basePortDifferent): ORBBase(basePortDifferent) {
        initialise(argc, argv, transportNameIn, ipAddress, extraProperties); // initialise the communicator and adapter
    }

    /** Generates a new ZeroC ICE application layer originator.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting (used by ORBReplicator)
    \param extraProperties Extra communicator properties to initialise the communicator with
    */
    void initialise(int argc, char *argv[], string transportNameIn, string ipAddress, const vector<pair<string,string> > extraProperties) {
        communicator=NULL;
        hostAddress=ipAddress;
        portOffset=getPortOffset(); // get a unique port offset
        transportName=transportNameIn; // set the ZeroC ICE application layer name
        Ice::InitializationData initData; // generate required initialisation data
        initData.properties = Ice::createProperties();
        initData.properties->setProperty("Ice.Warn.Connections", "2");
        initData.properties->setProperty("Ice.Warn.UnusedProperties", "1");
        // parse the extra properties
        for (vector<pair<string,string> >::const_iterator pss=extraProperties.begin(); pss!=extraProperties.end(); ++pss)
            initData.properties->setProperty(pss->first, pss->second);

        communicator = Ice::initialize(argc, argv, initData); // create the communicator
    }

    /** Creates an adapter, as required by the ORBOriginator but not the ORBReplicator.
    */
    void initialiseAdapter(void) {
        //cout<<"enpoint string "<<generateEndPoint(transportName, string(), portOffset).c_str()<<endl;
        adapterPtr=communicator->createObjectAdapterWithEndpoints(transportName+".Control",generateEndPoint(transportName, hostAddress, portOffset).c_str());
        adapterPtr->add((ORB::ORBICE*)this, communicator->stringToIdentity(transportName)); // add this class to the adapter
        adapterPtr->activate();
    }

    /** This method implements the netowrk protocol ORB::ORBICE::getObjectPointer.
    The protocol for this method is specified in the ORBICE.ice network protocol specification file.
    */
    void getObjectPointer(const string &name, Ice::ObjectPtr &objectPointer, const Ice::Current& cur) {
        Ice::Identity identity;
        identity.name=name;
        objectPointer=adapterPtr->find(identity);
        //cout<<"objectPointer = "<<objectPointer<<endl;
    }

public:
    /** Generates a new application layer originator for class Object Broking.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated.
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn) {
        initialise(argc, argv, transportNameIn, string(), vector<pair<string,string> >()); // initialise the communicator and adapter
        initialiseAdapter();
    }

    /** Generates a new application layer originator for Object Broking.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated.
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param basePortDifferent Specify a different base port to the default normally used by ORBBase
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, int basePortDifferent): ORBBase(basePortDifferent) {
        initialise(argc, argv, transportNameIn, string(), vector<pair<string,string> >()); // initialise the communicator and adapter
        initialiseAdapter();
    }

    /** Generates a new application layer originator for class Object Broking.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param extraProperties Extra communicator properties to initialise the communicator with
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, const vector<pair<string,string> > extraProperties) {
        initialise(argc, argv, transportNameIn, string(), extraProperties); // initialise the communicator and adapter
        initialiseAdapter();
    }

    /** Generates a new application layer originator for Object Broking.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated.
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param extraProperties Extra communicator properties to initialise the communicator with
    \param basePortDifferent Specify a different base port to the default normally used by ORBBase
    */
    ORBOriginator(int argc, char *argv[], string transportNameIn, const vector<pair<string,string> > extraProperties, int basePortDifferent): ORBBase(basePortDifferent) {
        initialise(argc, argv, transportNameIn, string(), extraProperties); // initialise the communicator and adapter
        initialiseAdapter();
    }

    /// Destructor
    virtual ~ORBOriginator(void) {
        removePortOffset(portOffset);
        if (communicator)
            communicator->shutdown();
    }

    /** An ICE network call to shutdown the communicator.
    \param cur The current ICE object
    */
    void shutdown(const Ice::Current& cur) {
        cur.adapter->getCommunicator()->shutdown();
    }

    /** Find out the state of the ORB origin.
    \return true if shutdown has been called, returns true if the communicator is not allocated.
    */
    bool isShutdown(){
        if (communicator)
            return communicator->isShutdown();
        return true;
    }

    /** Make the network aware that a new class is available to the ORB application layer.
    \param objectToORB The calss which will be added to the ORB application layer
    \param name The name to give to the network. This name must be unique
    */
    void addClass(Ice::ObjectPtr objectToORB, const string &name) {
        Ice::Identity identity;
        identity.name=name;
        if (adapterPtr->find(identity)) // check whether it already exists
            cerr<<"ORBOriginator::addClass : WARNING : that class is already serlialised on the adapter"<<endl;
        adapterPtr->add(objectToORB, identity);
    }

    /** Run the ICE thread
    */
    void waitForShutdown(void) {
        communicator->waitForShutdown();
    }

//    void remove(const string &name){
//        Ice::Identity ident;
//        ident.name=name;
//        if (adapterPtr->find(ident)){
//            cout<<name<<" found, removing"<<endl;
//            adapterPtr->remove(ident);
//        }
//    }
};

/** Sets up a replicator which connects to an originator.

The local proxy objects will operate the originator's object's methods, get the proxy using the ORBReplicator::getObjectProxy method.

The local pointer objects will access the originator's object's variables, get the pointer using the ORBReplicator::getObjectPointer method.

Each ORBReplicator class must implement the purely virtual method ORBReplicator::create to instruct the class factory which classes to generate and how.
*/
class ORBReplicator : public Ice::ObjectFactory, public ORBOriginator {
    ORB::ORBICEPrx oRBOriginatorPrx; ///< The proxy of the ORBOriginator on the other side of the network

    /** Method required by Ice::ObjectFactory
        */
    void destroy() {
    }

    /** Gets the ORBOriginator proxy and sets the oRBOriginatorPrx variable.
    Upon failure, an assertion is generated (this may need to be replaced in future).
    */
    void initialise(void) {
        try {
            oRBOriginatorPrx = ORB::ORBICEPrx::checkedCast(communicator->stringToProxy(generateEndPoint(transportName, hostAddress, portOffset).c_str())->ice_twoway()->ice_timeout(-1)->ice_secure(false));
        } catch (const Ice::Exception& e) {
            cerr << e << endl;
        } catch (...) { cout << "unknown exception"; }
        if (!oRBOriginatorPrx) {
            cerr<<"ORBReplicator::initialise : couldn't get the ORBOriginator proxy, can't continue \n\n\tPlease check that the intended application on the other side of the netowrk is up and running!"<<endl;
            //assert(false);
        }
    }

public:
    /** Generates a new ZeroC ICE application layer replicator.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting
    */
    ORBReplicator(int argc, char *argv[], string transportNameIn, string ipAddress) : ORBOriginator(argc, argv, transportNameIn, ipAddress) {
        initialise();
    }

    /** Generates a new ZeroC ICE application layer replicator.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting
    \param basePortDifferent Specify a different base port to the default normally used by ORBBase
    */
    ORBReplicator(int argc, char *argv[], string transportNameIn, string ipAddress, int basePortDifferent) : ORBOriginator(argc, argv, transportNameIn, ipAddress, basePortDifferent) {
        initialise();
    }

    /** Generates a new ZeroC ICE application layer replicator.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated.
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting
    \param extraProperties Extra communicator properties to initialise the communicator with
    */
    ORBReplicator(int argc, char *argv[], string transportNameIn, string ipAddress, const vector<pair<string,string> > extraProperties) : ORBOriginator(argc, argv, transportNameIn, ipAddress, extraProperties) {
        initialise();
    }

    /** Generates a new ZeroC ICE application layer replicator.
    The endpoints of the application layer are derived by ORBBase.
    The ice configuration transportName.Control and transportName.Endpoints are auto-generated.
    \param argc The command line argument count
    \param argv The command line arguments
    \param transportNameIn The name of this application layer, which enables ICE to lookup using the appropriate endpoints
    \param ipAddress the host to connect to whos endpoints should be open and ready for connecting
    \param extraProperties Extra communicator properties to initialise the communicator with
    \param basePortDifferent Specify a different base port to the default normally used by ORBBase
    */
    ORBReplicator(int argc, char *argv[], string transportNameIn, string ipAddress, const vector<pair<string,string> > extraProperties, int basePortDifferent) : ORBOriginator(argc, argv, transportNameIn, ipAddress, extraProperties, basePortDifferent) {
        initialise();
    }

    /** Each of your overloaded classes must implement the ORBOriginator::create method.
        This is the method which is called to create your desired class when required.
        */
    virtual Ice::ObjectPtr create(const std::string&)=0;

//    /* Register a class with the object factory.
//    When required ORBOriginator::create will make the required class.
//    \param The unique id which identifies the class to create
//    \tparam ICEIDTYPE The class to get the static id from
//    */
//    template<typename ICEIDTYPE>
//    void addObjectFactory(void) {
//        communicator->addObjectFactory(static_cast<Ice::ObjectFactory*>(this), ICEIDTYPE::ice_staticId()); // register that the factory can now generate the specified class
//    }

    /** Overload this method so that it doesn't get called by mistake in a replicator.
    \param objectToORB The calss which will be added to the ORB application layer
    \param name The name to give to the network. This name must be unique
   */
    void addClass(Ice::ObjectPtr objectToORB, const string &name) {
        cerr<<"ORBReplicator::addClass : Only ORBOriginators can add classes to the ORB application layer\n\t You need an originator on this side to add your classes to the ORB application layer"<<endl;
    }

    /** Tell the SerlialiseOriginator to shutdown.
    */
    void shutdown(void) {
        oRBOriginatorPrx->shutdown(); // call the Originator's shutdown method
    }

    /** Get a proxy from the ORB layer (this will give you access to the methods on the originator).
    The proxy must be set using the ORBOriginator::addClass method first.
    \param nameIn The name of the class we are looking for on the ORB network
    \return desired proxy or NULL on failure
    \tparam PRXTYPE The class which we want to get from the ORB network
    */
    template<typename PRXTYPE>
    PRXTYPE getObjectProxy(const string &nameIn) {
        return PRXTYPE::checkedCast(communicator->stringToProxy(generateEndPoint(nameIn, hostAddress, portOffset).c_str()));
    }

    /** Get a calss from the ORB layer (this will give you access to the variables as they are on the originator
    however the methods run on the replicator).
    It is like creating the class locally but setting its state to be identical to that of the same clas on the originator at
    the point in time the method is executed.
    The proxy must be set using the ORBOriginator::addClass method first.
    This method returns a pointer to CLASSTYPE which is not memory managed. Ensure you call CLASSTYPE *c; c->__setNoDelete(false); to re-enable memory management
    \param nameIn The name of the class we are looking for on the ORB network
    \return desired pointer or NULL on failure
    \tparam CLASSTYPE The class which we want to get from the ORB network - must match the nameIn used in the ORBOriginator::addClass AND the iceIdIn
    */
    template<typename CLASSTYPE>
    CLASSTYPE *getObjectPointer(const string &nameIn) {
        if (!communicator->findObjectFactory(CLASSTYPE::ice_staticId())) // add the object to the factory if it is missing
            communicator->addObjectFactory(static_cast<Ice::ObjectFactory*>(this), CLASSTYPE::ice_staticId()); // register that the factory can now generate the specified class

        // request the object from the ORBOriginator, and create it using the factory.
        Ice::ObjectPtr objectPtr;
        oRBOriginatorPrx->getObjectPointer(nameIn, objectPtr);
        objectPtr->__setNoDelete(true); // we have to memory manage ourselves
        //return PTRTYPE::dynamicCast(objectPtr); // this was used previously to return the pointer
        return dynamic_cast<CLASSTYPE *>(objectPtr.get());
    }

    /** Find out whether we connected to the other side ok.
    \return true if connected, false if not.
    */
    bool connectedOK(){
        return (bool)oRBOriginatorPrx!=NULL;
    }
};

};
#endif // ORB_H_
